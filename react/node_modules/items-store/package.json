{
  "name": "items-store",
  "version": "0.3.0",
  "description": "A flux-like architecture with a syncing items store",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:webpack/items-store.git"
  },
  "keywords": [
    "react",
    "flux",
    "store",
    "sync",
    "items"
  ],
  "author": {
    "name": "Tobias Koppers @sokra"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/webpack/items-store/issues"
  },
  "homepage": "https://github.com/webpack/items-store",
  "peerDepenencies": {
    "react": "^0.12.0"
  },
  "readme": "# items-store\r\n\r\nA flux-like architecture with a syncing items store.\r\n\r\n## Idea\r\n\r\n### ItemsStore\r\n\r\nA store that manages read and write access to items (accessed by a string id).\r\n\r\nIt\r\n\r\n* offers synchronous access to items\r\n* caches items after reading\r\n* fires update events for items\r\n* merges multiple writes to items\r\n* writes do optimistic updates\r\n\r\n### ItemsStoreFetcher\r\n\r\nA helper which repeatedly calls a function until all references items are available. The ItemsStoreFetcher can fetch from multiple stores.\r\n\r\n### ItemsStoreLease\r\n\r\nA helper class which leases multiple items from multiple stores. It captures dependencies from calling a function.\r\n\r\n## StateFromStoresMixin\r\n\r\nA react component mixin that provides component state from stores.\r\n\r\nThe component provides a **static** `getState` method that calculate state from stores (and params when using react-router). The mixin handles listening to changes and charging of stores.\r\n\r\nThe usable API inside the `getState` method is very simple and synchronous. See API > StateFromStoresMixin.\r\n\r\n\r\n## API\r\n\r\n### `ItemsStore`\r\n\r\n#### `new ItemsStore(desc, [initialData])`\r\n\r\nThe constructor.\r\n\r\n`desc` A description of the store. The creator provides options and read/write methods that the store will use.\r\n\r\n`initialData` An object containing initial item data. You may pass the result of `getData` here. This should be used for initializing the stores after server-side rendering.\r\n\r\n#### `desc`\r\n\r\nThe store description. The behavior of the store changes depending on the contained keys. Can contain these keys:\r\n\r\n**reading and writing**\r\n\r\n`readSingleItem: function(item, callback)` Reads a single item. `item` is an object `{ id: string, oldData: any|undefined }`. `callback` is a `function(err, newData: any|undefined)`.\r\n\r\n`readMultipleItems: function(items, callback)` Reads multiple items. Similar to `readSingleItem` but `items` is an array and the `callback` is a `function(err, newDatas: object)` where `newDatas` is an object containing items id as key (prefixed with any single char) and value is the new data. i. e. `{\"_12345\": { name: \"item 12345\" }}`.\r\n\r\n`writeSingleItem: function(item, callback)` Writes a single item. `item` is an object `{ id: string, update: any, oldData: any|undefined, newData: any }`. `callback` is a `function(err)`.\r\n\r\n`writeMultipleItems: function(items, callback)` Writes multiple items. Similar to `writeSingleItem` but `items` is an array.\r\n\r\n`createSingleItem: function(item, callback)` Creates a single item. `item` is an object `{ data: any }`. `callback` is a `function(err, newId)`.\r\n\r\n`createMultipleItems: function(items, callback)` Creates multiple items. Similar to `createSingleItem` but `items` is an array.\r\n\r\n`deleteSingleItem: function(item, callback)` Deletes a single item. `item` is an object `{ id: string }`. `callback` is a `function(err)`.\r\n\r\n`deleteMultipleItems: function(items, callback)` Deletes multiple items. Similar to `deleteSingleItem` but `items` is an array.\r\n\r\n`writeAndReadSingleItem: function(item, callback)` A combination of `writeSingleItem` followed by a `readSingleItem`.\r\n\r\n`writeAndReadMultipleItems: function(items, callback)` A combination of `writeMultipleItems` followed by a `readMultipleItems`.\r\n\r\n`createAndReadSingleItem: function(items, callback)` A combination of `createSingleItem` followed by a `readSingleItem`. `callback` is `function(err, newId, newData)`.\r\n\r\n`createAndReadMultipleItems: function(items, callback)` A combination of `createMultipleItems` followed by a `readMultipleItems`. `callback` is `function(err, newIds: array, newDatas: object)`.\r\n\r\n`maxCreateItems` Maximum of items allowed to be created by `createMultipleItems` or `createAndReadMultipleItems`.\r\n\r\n`maxWriteItems` Maximum of items allowed to be written by `writeMultipleItems` or `writeAndReadMultipleItems`.\r\n\r\n`maxDeleteItems` Maximum of items allowed to be delete by `deleteMultipleItems`.\r\n\r\n`maxReadItems` Maximum of items allowed to be read by `readMultipleItems`.\r\n\r\nYou need to provide at least one read method. If you want to do updates you need to provide at least one write or writeAndRead method.\r\n\r\nReading or writing multiple items is preferred if more than one items should be read or written.\r\n\r\nwriteAndRead methods are preferred over write methods.\r\n\r\nIf multiple requests are scheduled they are processed in this order: 1. create, 2. write, 3. delete, 3. read.\r\n\r\n**updates**\r\n\r\n`applyUpdate: function(data, update)` Apply an update to existing data. The new data is returned. Doesn't modify `data`.\r\n\r\n`applyUpdate` defaults to an method that merges (flat) the keys from `update` into `data`.\r\n\r\n`mergeUpdates: function(a, b)` Merges two update. A new update is returned that represents applying update `a` and `b`.\r\n\r\n`mergeUpdates` default to an flat merge.\r\n\r\n`rebaseUpdate: function(update, oldData, newData)` Called when new data is received while an item was already changed locally. Returns a new update that behaves to `newData` like `update` to `oldData`.\r\n\r\n`rebaseUpdate` default to an identity function that just returns `update`.\r\n\r\n**timing**\r\n\r\n`queueRequest: function(fn)` Called when the store want to do something. It's called with a async function `fn(callback)` that should be called sometime in the future. You should wait at least one tick before calling `fn` if you want multiple reads/writes to be merged. You can use a shared queue to queue from multiple stores.\r\n\r\nDefaults to `process.nextTick`.\r\n\r\n#### `getItem(id)`\r\n\r\nReturns the current data of the item `id`. Returns `undefined` if no data is available. May return outdated cached data.\r\n\r\n#### `getItemInfo(id)`\r\n\r\nReturns status information about the item `id`. Returns an object with these keys:\r\n\r\n`available` Any data is available.\r\n\r\n`outdated` The item is outdated and a read is queued or will be queue when the item is read.\r\n\r\n`updated` The item was changed and a write is queued.\r\n\r\n`listening` Somebody is interested in this item.\r\n\r\n#### `isItemAvailable(id)`\r\n\r\nReturns `true` if any data is available.\r\n\r\n#### `isItemUpToDate(id)`\r\n\r\nReturns `true` if data is available and not outdated.\r\n\r\n#### `listenToItem(id, handler)`\r\n\r\nListen to changes of the item `id`. `handler` is called with the new data. A lease is returned which has a single method `close` which stops listening.\r\n\r\nWhen calling `listenToItem` twice with the same `id` and `handler` no new lease is created. Instead the old lease is returned.\r\n\r\nCalling this method may trigger a read to the item.\r\n\r\n#### `waitForItem(id, callback)`\r\n\r\nWaits until the item `id` is up to date and calls the `callback` once it's up to date.\r\n\r\nCalling this method may trigger a read to the item.\r\n\r\n#### `getData()`\r\n\r\nReturns an object containing the data for every available item.\r\n\r\n#### `updateItem(id, update)`\r\n\r\nApplies the `update` to item `id`. The format of `update` depends on the provided `applyUpdate` implementation.\r\n\r\nCalling this method trigger a write to the item.\r\n\r\n#### `createItem(data, [callback])\r\n\r\nTriggers a server request to create a new item. `callback` is called with the server response.\r\n\r\n#### `deleteItem(id, [callback])\r\n\r\nTriggers a server request to delete an item. `callback` is called with the server response.\r\n\r\n#### `outdate()`\r\n\r\nDefines all available items as outdated.\r\n\r\n#### `outdate(id)`\r\n\r\nDefines item `id` as outdated.\r\n\r\n#### `update([all])`\r\n\r\nDefines all available items as outdated and\r\n\r\n* `all = false` (default): triggers reads for items which are listened.\r\n* `all = true`: triggers reads for all items\r\n\r\n#### `update(id)`\r\n\r\nDefines item `id` as outdated and triggers a read.\r\n\r\n#### `setItemData(id, newData)`\r\n\r\nSets the current item data `newData` for the item `id`. Should only be called when receiving data from a higher instance i. e. from the server or database.\r\n\r\nYou can use it in provided read and write methods when getting more information that the requested one. You should use this method when receiving data from an open stream.\r\n\r\n\r\n### `ItemsStoreFetcher`\r\n\r\n#### static `fetch(fn, callback)`\r\n\r\nCalls `fn` (`function(addDependency)`) multiple times until all referenced items are available. Than calls `callback` (`function(err, result)`) with the return value.\r\n\r\nIf `fn` throws an error `callback` is called immediately with the error.\r\n\r\nThe provided function `addDependency(Store, id)` tell the fetcher that the `fn` used `Store` to read an item `id`. You must call it for each item read. You must not write to stores.\r\n\r\n\r\n### `ItemsStoreLease`\r\n\r\n#### `new ItemsStoreLease()`\r\n\r\nCreate a new instance.\r\n\r\n#### `capture(fn, onUpdate)`\r\n\r\nCalls `fn` (`function(addDependency)`) and starts listening to item updates (if not already listening). `onUpdate` is called when an item was updated. Calling this method also stops listening to items that are no longer referenced by the `fn`.\r\n\r\nThe provided function `addDependency(Store, id)` tell the fetcher that the `fn` used `Store` to read an item `id`. You must call it for each item read. You must not write to stores.\r\n\r\n#### `close()`\r\n\r\nStops listening to item updates.\r\n\r\n\r\n### `StateFromStoresMixin`\r\n\r\nMixin for react component.\r\n\r\nIt uses update batching of react, so you **must** ensure that all calls to `ItemsStore.setItemData` and callbacks of `read...` are inside the react event system, batched with `ReactUpdates.batchedUpdates` or use a continuous batching strategy (i. e. `ReactRAFBatchingStrategy`).\r\n\r\n**component**\r\n\r\nIt's expected from the component to provide a static `getState` function.\r\n\r\nThe context of the component must contain a key `stores` which is an object containing all stores (i. e. `{Messages: [ItemsStore], Users: [ItemsStore]}`).\r\n\r\n#### static `getState(stores, params)`\r\n\r\nThis function should create the component state from `stores` and `params` and return it.\r\n\r\n`stores` is an object containing a dependency-tracking version of each store i. e. \r\n```\r\n{\r\n\tMessages: {\r\n\t\tgetItem: [Function],\r\n\t\tgetItemInfo: [Function],\r\n\t\tisItemAvailable: [Function],\r\n\t\tisItemUpToDate: [Function]\r\n\t},\r\n\tUsers: {\r\n\t\tgetItem: [Function],\r\n\t\tgetItemInfo: [Function],\r\n\t\tisItemAvailable: [Function],\r\n\t\tisItemUpToDate: [Function]\r\n\t}\r\n}\r\n```\r\n\r\n`params` is the params object from `react-router` (if used)\r\n\r\nExample for a `getState` method:\r\n\r\n``` javascript\r\nstatics: {\r\n\tgetState: function(stores, params) {\r\n\t\tif(!stores.Threads.isItemAvailable(params.threadId))\r\n\t\t\treturn { loading: true };\r\n\t\tvar thread = stores.Threads.getItem(params.threadId);\r\n\t\treturn {\r\n\t\t\tthread: thread,\r\n\t\t\tmessages: thread.messages.map(function(messageId) {\r\n\t\t\t\tvar message = stores.Messages.getItem(messageId);\r\n\t\t\t\treturn message && Object.assign({}, message, {\r\n\t\t\t\t\tuser: stores.Users.getItem(message.userId)\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n**hooks**\r\n\r\n#### `getInitialState`\r\n\r\nReturns the initial state generated by the static `getState` method.\r\n\r\n#### `componentWillReceiveProps`\r\n\r\nWhen the context is changed by react-router, i. e. when the params changed, state is updated.\r\n\r\n**methods**\r\n\r\n#### static `chargeStore(stores, params, callback)`\r\n\r\nPrepares stores with an `ItemsStoreFetcher`.\r\n\r\n`stores` The object of `ItemsStores`, like the `stores` key in the context.\r\n\r\n`params` params object from `react-router`.\r\n\r\n### `Actions`\r\n\r\nHelpers to create actions:\r\n\r\n``` javascript\r\n{ [Function trigger]\r\n  listen: [Function listen]\r\n}\r\n```\r\n\r\nAn action can be triggered by calling it. Any number of arguments can be provided.\r\n\r\nAn action has a `listen` (`function(callback, bindContext)`) method to listen to the action.\r\n\r\n``` javascript\r\nvar singleAction = Actions.create();\r\nsingleAction(); // trigger\r\nsingleAction(1, 2, \"hello\"); // trigger with actions\r\nsingleAction.listen(function(a, b, c) {\r\n\tconsole.log(a, b, c);\r\n}, this);\r\n\r\nvar actions = Actions.create([\r\n\t\"someAction\",\r\n\t\"otherAction\"\r\n]);\r\nactions.someAction();\r\nactions.otherAction(\"other\");\r\n```\r\n\r\n#### `create([names])`\r\n\r\nCreates a single action (without `names` parameter) or multiple actions (with `names` (`string[]`) parameter).\r\n\r\n\r\n## Example\r\n\r\nhttps://github.com/webpack/react-starter\r\n\r\n\r\n## TODO\r\n\r\n* `readAndStreamSingleItem`, `readAndStreamMultipleItems`\r\n* Timeout for cached data\r\n* Maximum size of cached data\r\n\r\n\r\n## License\r\n\r\nCopyright (c) 2014 Tobias Koppers [![Gittip donate button](http://img.shields.io/gittip/sokra.png)](https://www.gittip.com/sokra/)\r\n\r\nMIT (http://www.opensource.org/licenses/mit-license.php)\r\n\r\n",
  "readmeFilename": "README.md",
  "_id": "items-store@0.3.0",
  "dist": {
    "shasum": "25f6edd92f2ed794613d49307b1b0af36f294e40"
  },
  "_from": "items-store@^0.3.0",
  "_resolved": "https://registry.npmjs.org/items-store/-/items-store-0.3.0.tgz"
}
